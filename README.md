<响应式架构 -- 消息模式Actor实现与Scala,Akka应用集成>
笔记:

--------------
## 什么是Actor模型?

Actor模型使Actor对象能够像第一类值一样被处理,并通过消息传递功能加强了Actor对象之间的通信操作.因为消息是以异步方式发送的,所以对Actor对象执行的操作也是高度并发化的,这自然会使应用程序能够以并发方式解决问题.通常,每个Actor对象都负责单个的应用程序任务.
**因为Actor是一种无锁的并发代理对象,而且执行它们的线程通常不会被阻塞,所以使用Actor对象设计的应用程序能够完美地利用系统的基础线程资源.**


Actor模型是一种用于处理并发计算的数学模型,它将Actor对象用做并发计算的通用单元.与其他计算模型不同,发明Actor模型的灵感源于物理学理论,如广义相对论和量子力学[Actor,Model]

可以将Actor模型视为创建响应式应用程序的手段之一.使用这种具体的响应式软件开发方法,可以细致地处理响应式应用程序的主要方面:响应性,韧性,弹性和消息驱动性.

Actor系统和Actor对象具有下列基本特点:

- 直接通过异步消息传递方式进行通信(ZMQ传输)
- 状态机:通过变为另一种消息处理器,Actor对象就成了一种有限状态机
- 无共享:一个Actor对象不会与其他Actor对象或相关组件共享可变状态
- 无锁的并发处理方式:因为Actor对象不会共享它们的可变状态,而且在同一时刻仅会接收一条消息,所以在对消息回应前,Actor对象永远都不需要尝试锁定它们的状态
- 并行性
- Actor对象的系统性: Carl Hewitt博士说,单独存在的Actor对象不是Actor对象.在Actor系统中,Actor对象才能成为Actor对象.


-----------

当一条消息经过网络从一个Actor对象发送给另一个Actor对象时,消息本身一定会被序列化.该操作本身会增加系统开销,根据你选择的序列化类型,该系统开销可能会相当大.默认情况下,Akka框架使用Java序列化,这种序列化操作在性能和尺寸方面都比较差.因此,当你知道消息必须跨越多台JVM时,应因地制宜地选择适当的序列化操作.Protocol Buffers和Kryo是比较著名的序列化操作.可以配置你喜欢的序列化类型,并禁用Java序列化操作.

--------------
多线程开发中可能出现的问题:

- 死锁
- 活锁
- 饥饿
- 低效代码
- 伪共享


我们想要的是更简单的编写多线程软件的方式.如果临时耦合性是一个问题,那么我们就应该通过临时方式降低耦合性.使用**队列管理**由线程执行的各项工作,通常是推荐的处理方式.一个线程向队列中添加新的任务时,处理工作的线程(工人线程)会从队列中取出任务.因为所有工人线程都会从工作队列取出它们的下一个任务,所以这能够减少线程之间的联系.这样线程之间的耦合性就会更低了.



